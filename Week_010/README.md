**1. 复杂度分析**

**1.1 时间复杂度**

- O(1) 常数复杂度。例：堆获取最大值、最小值
- O(logn) 对数复杂度。例：二分查找、二叉树查找
- O(nlogn) 复杂度。例：归并排序、快速排序、堆排序 等
- O(n) 线性时间复杂度。例：树的前、中、后遍历
- O(n^2) 平方。例： 冒泡排序、希尔排序、选择排序、插入排序 等
- O(2^n) 指数。例：递归
- O(n!) 阶乘。例：N皇后

**1.2 空间复杂度**

- 数组的长度
- 递归的深度

**2. 数据结构**

**2.1 一维数据结构**

- 数组 array

- - 使用一组连续的内存空间来存储数据

  - 时间复杂度：随机访问 O(1)、插入 O(n)、删除 O(n)、增加 O(1)

  - 优点

  - - 简单易用、可以利用CPU缓存机制

  - 缺点

  - - 大小固定，占用整块内存空间。如果系统没有足够的连续内存空间分配给它，导致“内存不足”。如果数组过小，出现不够用的情况。只能再申请一个更大的内存空间，把原数组拷贝进去，费时

- 链表 linked list

- - 单向链表、双向链表、循环链表、双向链表、跳表skip list、 等

  - 单向链表:

  - - 时间复杂度：随机访问 O(n)、插入 O(1)、删除 O(1)、添加 O(1)

  - 双向链表：每个节点两个指针，一个指向前一个节点，一个指向后节点。可以支持 O(1) 的时间复杂度找到前驱节点

  - 循环链表：尾指针指向头节点形成一个环，适合处理环形数据的问题，从链头到链尾比较方便。

  - 跳表：升维，空间换时间。插入／删除／搜索时间复杂度都是 O(logn) 的数据结构。

  - - 优点：效率高、原理简单容易实现、在一些项目用平衡树代替
    - 缺点：只能用在有序元素情况、元素的插入和删除需要更新索引，维护成本高

  - 链表整体优点：

  - - 与数组相比没有大小限制

  - 链表整体缺点：

  - - 链表在内存中并不是连续存储，对CPU缓存不友好，没法有效预读

- 栈 stack

- - 先入后出

  - 时间复杂度：入栈出栈O(1)、查询 O(n)

  - 应用

  - - 浏览器页面的前进、后退
    - 括号匹配问题
    - 数学表达式计算

- 队列 queue

- - 普通队列

  - - 先入先出
    - 时间复杂度：入队出队 O(1)、查询 O(n)
    - 应用：资源操作池、相关 BFS 问题。

  - 双端队列

  - - 入口和出口都可以入对出队

  - 优先队列

  - - 根据优先级出队。
    - 应用：A*搜索

  - 其他队列：循环队列、阻塞队列、并发队列

- 集合 set

- - 去除重复的元素。

- 哈希表 hash table

- - 也叫散列表, 根据key进行直接访问的数据结构，通过key映射到表中的一个位置来访问

  - 两个核心问题

  - - 散列函数的设计
    - 冲突解决策略：开发寻址法、链表法

  - 时间复杂度 : 插入、删除、查询都为 O(1)

**2.2 二维数据结构**

**2.2.1 树 tree**

- 二叉树

- - 二叉树遍历

  - - 深度优先：前序、中序、后序、时间复杂度都为 O(n)
    - 广度优先

  - 平衡二叉树：红黑树、AVL 树

  - 满二叉树

  - 完全二叉树

- Trie 树

- 多路查找树

- - B树、B+树、2-3树、2-3-4 树

- 堆

- - 大顶堆、小顶堆

  - 应用

  - - 优先队列实现

**2.2.2 图 graph**

- 存储：

- - 顺序：邻接矩阵
  - 链式：邻接表

- 拓扑顺序

- 最短路径

- 关键路径

- 最小生成树

**2.3 特殊数据结构**

- 位运算 bitwise

- - 二进制和十进制相互转换。

  - 位运算实战要点

  - - 判断奇偶
    - 清零最低位
    - 得到最低位

  - 应用

  - - N 皇后

- 布隆过滤器 bloomFilter

- - 核心实现是一个超级大的二进制数组和一系列的哈希函数(也叫随机映射函数)组成。 可以用于检验一个元素是否在一个集合中。

  - 优点

  - - 空间效率和查询时间都远超一般的算法

  - 缺点

  - - 有一定的误识别率和删除困难

  - 应用

  - - 比特币网络
    - 分布式系统(Map-Reduce) - Hadoop、search engine
    - Redis 缓存
    - 垃圾邮件、评论等的过滤

- LRU Cache

- - 两个要素：大小、替换策略

  - - O(1) 查询
    - O(1) 修改、更新 

  - 替换策略

  - - [替换算法总揽](https://en.wikipedia.org/wiki/Cache_replacement_policies)

- 并查集

- - 并查集属于一种跳跃式的数据结构

  - 应用

  - - 组团、配对问题。判断两个群组是不是在同一个群组里，判断两个个体是不是在一个集合中。
    - Group or not。分析两个人是不是好友，朋友圈功能。

**3. 算法**

**3.1 排序**

- 比较类排序：通过比较来决定**元素间的相对次序**，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序

- - \1. 选择排序。每次找最小值，然后依次放到排序数组的起始位置。

  - \2. 插入排序。从前到后逐步构建有序排序，对于未排序的数据，在已排序序列中从后往前扫描，找到相应的位置并插入

  - \3. 冒泡排序。嵌套循环，每次看到相邻的元素如果逆序则交换。

  - \4. 快速排序。数组取标杆 pivot， 将小元素放在 pivot 左边，大元素放右侧，然后依次对右边和左边的子数组进行快排。以达到整个序列的有序。

  - \5. 归并排序-分治。

  - - 把长度为 n 的输入序列分成两个长度为 n/2 的子序列
    - 对这两个子序列分别采用归并排序
    - 将两个排序好的子序列合并成一个完整的序列

  - \6. 堆排序。堆插入(O log(N)), 取最大／最小值 O(1)。可以自建堆或使用heapq / Priority Queue 实现

  - - 数组元素依次建立最小堆
    - 依次取堆顶元素，并删除

  - \7. 希尔排序

- 非比较类排序，也叫特殊排序，特殊排序都可以是线性时间来完成的，但是要求元素本身是整数。

- - 计数排序 （Counting Sort）。要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存在额外开辟的数组空间，然后依次把计数大于1的填充回原数组。

  - - 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

  - 桶排序（bucket Sort）。桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。工作原理是：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归的形式继续使用桶排序）

  - 基数排序 (Radix Sort)。基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集，依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。 

**3.2 字符串匹配**

- 暴力法 (brute force)

- -  通过模式串与主串中是所有子串匹配，看是否有能匹配的子串。时间复杂度 O(n * m) .

- Rabin-Karp 算法

- - Rabin-Karp 算法也叫 RK 算法。借助哈希算法，对每个子串求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间，理想情况下，RK 算法的时间复杂度是 O(n)，不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。

- BM 算法

- KMP 算法

**3.3 搜索**

- 深度优先搜索

- 广度优先搜索

- A*搜索

- - 启发式搜索(Heuristic Search A*) , 可以认为是智能化搜索，或者根据某一项条件来采取不断的优化搜索方向。本质上就是通过优先级不断去找需要的点，先把优先级高的取出来搜索。

**3.4 查找**

- 二分查找。

**3.5 算法思想**

- **贪心算法**。

- - 贪心算法可以看作是动态规划的一种特殊情况。它解决的问题能满足三个条件：最优子结构、无后效性和贪心选择性。贪心选择性是指通过局部最优能产生全局最优的选择。与动态规划的不同在于对子问题通过选择，不能回退。而动态规划可以回退。

- **回溯算法**。

- - 回溯算法相当于是穷举搜索，然后对比找到最优解。可以用贪心和动态规划解决的问题，都可以通过回溯实现，不过时间复杂度比较高，是指数级别。只适用小规模数据问题。

- **分治**。

- - 分治算法解决的问题也是最优解问题，但是大部分都不能抽象成多阶段决策模型。

- **动态规划**

- - 适合用来解决最优问题，比如最大值、最小值等等。

  - 能用动态规划解决的问题需要满足 “**一个模型三个特征”** 。

  - - 一个模型：多阶段决策最优解模型。
    - 三个特征：最优子结构，无后效性，重复子问题。